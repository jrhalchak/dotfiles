--- FILE: /home/jrh/.config/nvim/after/queries/markdown/injections.scm ---
; extends
((inline) @injection.content
  (#lua-match? @injection.content "^%s*import")
  (#set! injection.language "typescript"))
((inline) @injection.content
  (#lua-match? @injection.content "^%s*export")
  (#set! injection.language "typescript"))

--- FILE: /home/jrh/.config/nvim/init.lua ---
require("jrh")


--- FILE: /home/jrh/.config/nvim/lazy-lock.json ---
{
  "CopilotChat.nvim": { "branch": "main", "commit": "16d897fd43d07e3b54478ccdb2f8a16e4df4f45a" },
  "LuaSnip": { "branch": "master", "commit": "5271933f7cea9f6b1c7de953379469010ed4553a" },
  "avante.nvim": { "branch": "main", "commit": "d3c93c0dabb4311d0af30940726fb0bff30a9676" },
  "blink.cmp": { "branch": "main", "commit": "022521a8910a5543b0251b21c9e1a1e989745796" },
  "cmp-buffer": { "branch": "main", "commit": "b74fab3656eea9de20a9b8116afa3cfc4ec09657" },
  "cmp-nvim-lsp": { "branch": "main", "commit": "a8912b88ce488f411177fc8aed358b04dc246d7b" },
  "cmp_luasnip": { "branch": "master", "commit": "98d9cb5c2c38532bd9bdb481067b20fea8f32e90" },
  "codecompanion.nvim": { "branch": "main", "commit": "9e4d4edd892a0e2ba0a2d874d5dfcfdc6575d08b" },
  "copilot.lua": { "branch": "master", "commit": "c1bb86abbed1a52a11ab3944ef00c8410520543d" },
  "dressing.nvim": { "branch": "master", "commit": "2d7c2db2507fa3c4956142ee607431ddb2828639" },
  "gitsigns.nvim": { "branch": "main", "commit": "d0f90ef51d4be86b824b012ec52ed715b5622e51" },
  "img-clip.nvim": { "branch": "main", "commit": "d8b6b030672f9f551a0e3526347699985a779d93" },
  "incline.nvim": { "branch": "main", "commit": "0fd2d5a27504dba7fdc507a53275f22c081fe640" },
  "lazy.nvim": { "branch": "main", "commit": "6c3bda4aca61a13a9c63f1c1d1b16b9d3be90d7a" },
  "lazydev.nvim": { "branch": "main", "commit": "2367a6c0a01eb9edb0464731cc0fb61ed9ab9d2c" },
  "mason-lspconfig.nvim": { "branch": "main", "commit": "bef29b653ba71d442816bf56286c2a686210be04" },
  "mason.nvim": { "branch": "main", "commit": "8024d64e1330b86044fed4c8494ef3dcd483a67c" },
  "mcphub.nvim": { "branch": "main", "commit": "7752efc63da929683c5d4812e7d0d066189ee68f" },
  "nui.nvim": { "branch": "main", "commit": "de740991c12411b663994b2860f1a4fd0937c130" },
  "nvim-cmp": { "branch": "main", "commit": "b5311ab3ed9c846b585c0c15b7559be131ec4be9" },
  "nvim-dev-container": { "branch": "main", "commit": "ba9666bdaec23cfe8087c0b6bb0a15c93ec8ba87" },
  "nvim-lspconfig": { "branch": "master", "commit": "a182334ba933e58240c2c45e6ae2d9c7ae313e00" },
  "nvim-treesitter": { "branch": "master", "commit": "42fc28ba918343ebfd5565147a42a26580579482" },
  "nvim-web-devicons": { "branch": "master", "commit": "1fb58cca9aebbc4fd32b086cb413548ce132c127" },
  "oil.nvim": { "branch": "master", "commit": "08c2bce8b00fd780fb7999dbffdf7cd174e896fb" },
  "plenary.nvim": { "branch": "master", "commit": "857c5ac632080dba10aae49dba902ce3abf91b35" },
  "render-markdown.nvim": { "branch": "main", "commit": "6f5a4c36d9383b2a916facaa63dcd573afa11ee8" },
  "snacks.nvim": { "branch": "main", "commit": "bc0630e43be5699bb94dadc302c0d21615421d93" },
  "tailwindcss-colorizer-cmp.nvim": { "branch": "main", "commit": "3d3cd95e4a4135c250faf83dd5ed61b8e5502b86" },
  "telescope-ui-select.nvim": { "branch": "master", "commit": "6e51d7da30bd139a6950adf2a47fda6df9fa06d2" },
  "telescope.nvim": { "branch": "master", "commit": "a0bbec21143c7bc5f8bb02e0005fa0b982edc026" },
  "tokyonight.nvim": { "branch": "main", "commit": "057ef5d260c1931f1dffd0f052c685dcd14100a3" },
  "which-key.nvim": { "branch": "main", "commit": "370ec46f710e058c9c1646273e6b225acf47cbed" }
}

--- FILE: /home/jrh/.config/nvim/lua/.luarc.json ---
{
  "diagnostic": {
    "globals": ["vim"]
  }
}

--- FILE: /home/jrh/.config/nvim/lua/plugins/netrw.lua ---
--  local keymaps = require("config.keymaps")

return {
--    {
--      'prichrd/netrw.nvim',
--      dependencies = { "nvim-tree/nvim-web-devicons" },
--      opts = {},
--      config = function()
--        require("netrw").setup({
--          -- File icons to use when `use_devicons` is false or if
--          -- no icon is found for the given file type.
--          icons = {
--            symlink = '',
--            directory = '',
--            file = '',
--          },
--          -- Uses mini.icon or nvim-web-devicons if true, otherwise use the file icon specified above
--          use_devicons = true,
--          mappings = keymaps.get_netrw(),
--        })
--      end,
--    }
}

--- FILE: /home/jrh/.config/nvim/lua/plugins/copilot.lua ---
return {
  {
    "CopilotC-Nvim/CopilotChat.nvim",
    dependencies = {
      { "zbirenbaum/copilot.lua" }, -- or github/copilot.vim
      { "nvim-lua/plenary.nvim", branch = "master" }, -- for curl, log and async functions
    },
    -- build = "make tiktoken", -- Only on MacOS or Linux
    -- opts = {
    --   -- See Configuration section for options
    -- },
    -- See Commands section for default commands if you want to lazy load on them
    config = function()
      require"copilot".setup{}
      require"CopilotChat".setup{}
    end
  },
  -- {
  --   "zbirenbaum/copilot.lua",
  --   -- Remove once https://github.com/LazyVim/LazyVim/pull/5900 is released
  --   opts = function()
  --     require("copilot.api").status = require("copilot.status")
  --   end,
  -- },
{
		{
			"ravitemer/mcphub.nvim",
			dependencies = {
				"nvim-lua/plenary.nvim",
			},
			build = "npm install -g mcp-hub@latest",
			config = function()
				require("mcphub").setup({
					port = 5999,
					config = vim.fn.expand("~/.config/lvim/lvim-mcp-servers.json"),
				})
			end,
		},
	},
	{
		"yetone/avante.nvim",
		event = "VeryLazy",
		version = false, -- Never set this value to "*"! Never!
		opts = {
			-- for example
			provider = "copilot",
			copilot = {
				-- model = "claude-3.7-sonnet-thought", -- your desired model (or use gpt-4o, etc.)
				model = "claude-3.5-sonnet", -- your desired model (or use gpt-4o, etc.)
			},
			-- The system_prompt type supports both a string and a function that returns a string. Using a function here allows dynamically updating the prompt with mcphub
			system_prompt = function()
				local hub = require("mcphub").get_hub_instance()
				return hub:get_active_servers_prompt()
			end,
			-- The custom_tools type supports both a list and a function that returns a list. Using a function here prevents requiring mcphub before it's loaded
			custom_tools = function()
				return {
					require("mcphub.extensions.avante").mcp_tool(),
				}
			end,
		},
		-- if you want to build from source then do `make BUILD_FROM_SOURCE=true`
		build = "make",
		-- build = "powershell -ExecutionPolicy Bypass -File Build.ps1 -BuildFromSource false" -- for windows
		dependencies = {
			"nvim-treesitter/nvim-treesitter",
			"stevearc/dressing.nvim",
			"nvim-lua/plenary.nvim",
			"MunifTanjim/nui.nvim",
			"nvim-telescope/telescope.nvim", -- for file_selector provider telescope
			"hrsh7th/nvim-cmp", -- autocompletion for avante commands and mentions
			"nvim-tree/nvim-web-devicons", -- or echasnovski/mini.icons
			{
				"zbirenbaum/copilot.lua",
				config = function()
					require("copilot").setup({})
				end,
				build = ":Copilot auth",
			},
			{
				-- support for image pasting
				"HakonHarnes/img-clip.nvim",
				event = "VeryLazy",
				opts = {
					-- recommended settings
					default = {
						embed_image_as_base64 = false,
						prompt_for_file_name = false,
						drag_and_drop = {
							insert_mode = true,
						},
						-- required for Windows users
						use_absolute_path = true,
					},
				},
			},
			{
				-- Make sure to set this up properly if you have lazy=true
				"MeanderingProgrammer/render-markdown.nvim",
				opts = {
					file_types = { "markdown", "Avante" },
				},
				ft = { "markdown", "Avante" },
			},
		},
	},
	{
		"olimorris/codecompanion.nvim",
		dependencies = {
			{ "nvim-treesitter/nvim-treesitter", build = ":TSUpdate" },
			{ "nvim-lua/plenary.nvim" },
			-- Test with blink.cmp
			{
				"saghen/blink.cmp",
				lazy = false,
				version = "*",
				opts = {
					keymap = {
						preset = "enter",
						["<S-Tab>"] = { "select_prev", "fallback" },
						["<Tab>"] = { "select_next", "fallback" },
					},
					cmdline = { sources = { "cmdline" } },
					sources = {
						default = { "lsp", "path", "buffer", "codecompanion" },
					},
				},
			},
			-- Test with nvim-cmp
			-- { "hrsh7th/nvim-cmp" },
		},
		opts = {
			--Refer to: https://github.com/olimorris/codecompanion.nvim/blob/main/lua/codecompanion/config.lua
			strategies = {
				--NOTE: Change the adapter as required
				chat = {
					adapter = "copilot",
					tools = {
						["mcp"] = {
							callback = function()
								return require("mcphub.extensions.codecompanion")
							end,
							description = "Call tools and resources from the MCP Servers",
							opts = {
								requires_approval = true,
							},
						},
					},
				},
				inline = { adapter = "copilot" },
			},
			opts = {
				log_level = "DEBUG",
			},
		},
	},
}


--- FILE: /home/jrh/.config/nvim/lua/plugins/docker.lua ---
return {
  {
    'https://codeberg.org/esensar/nvim-dev-container',
    dependencies = 'nvim-treesitter/nvim-treesitter',
    config = function()
      require("devcontainer").setup {
        -- config_search_start = function()
        --   -- By default this function uses vim.loop.cwd()
        --   -- This is used to find a starting point for .devcontainer.json file search
        --   -- Since by default, it is searched for recursively
        --   -- That behavior can also be disabled
        -- end,
        -- workspace_folder_provider = function()
        --   -- By default this function uses first workspace folder for integrated lsp if available and vim.loop.cwd() as a fallback
        --   -- This is used to replace `${localWorkspaceFolder}` in devcontainer.json
        --   -- Also used for creating default .devcontainer.json file
        -- end,
        -- terminal_handler = function(command)
        --   -- By default this function creates a terminal in a new tab using :terminal command
        --   -- It also removes statusline when that tab is active, to prevent double statusline
        --   -- It can be overridden to provide custom terminal handling
        -- end,
        -- nvim_installation_commands_provider = function(path_binaries, version_string)
        --   -- Returns table - list of commands to run when adding neovim to container
        --   -- Each command can either be a string or a table (list of command parts)
        --   -- Takes binaries available in path on current container and version_string passed to the command or current version of neovim
        -- end,
        -- devcontainer_json_template = function()
        --   -- Returns table - list of lines to set when creating new devcontainer.json files
        --   -- As a template
        --   -- Used only when using functions from commands module or created commands
        -- end,
        -- -- Can be set to false to prevent generating default commands
        -- -- Default commands are listed below
        -- generate_commands = true,
        -- -- By default no autocommands are generated
        -- -- This option can be used to configure automatic starting and cleaning of containers
        -- autocommands = {
        --   -- can be set to true to automatically start containers when devcontainer.json is available
        --   init = false,
        --   -- can be set to true to automatically remove any started containers and any built images when exiting vim
        --   clean = false,
        --   -- can be set to true to automatically restart containers when devcontainer.json file is updated
        --   update = false,
        -- },
        -- can be changed to increase or decrease logging from library
        log_level = "debug",
        -- -- can be set to true to disable recursive search
        -- -- in that case only .devcontainer.json and .devcontainer/devcontainer.json files will be checked relative
        -- -- to the directory provided by config_search_start
        -- disable_recursive_config_search = false,
        -- -- can be set to false to disable image caching when adding neovim
        -- -- by default it is set to true to make attaching to containers faster after first time
        -- cache_images = true,
        -- -- By default all mounts are added (config, data and state)
        -- -- This can be changed to disable mounts or change their options
        -- -- This can be useful to mount local configuration
        -- -- And any other mounts when attaching to containers with this plugin
        -- attach_mounts = {
        --   neovim_config = {
        --     -- enables mounting local config to /root/.config/nvim in container
        --     enabled = false,
        --     -- makes mount readonly in container
        --     options = { "readonly" }
        --   },
        --   neovim_data = {
        --     -- enables mounting local data to /root/.local/share/nvim in container
        --     enabled = false,
        --     -- no options by default
        --     options = {}
        --   },
        --   -- Only useful if using neovim 0.8.0+
        --   neovim_state = {
        --     -- enables mounting local state to /root/.local/state/nvim in container
        --     enabled = false,
        --     -- no options by default
        --     options = {}
        --   },
        -- },
        -- -- This takes a list of mounts (strings) that should always be added to every run container
        -- -- This is passed directly as --mount option to docker command
        -- -- Or multiple --mount options if there are multiple values
        -- always_mount = {},
        -- -- This takes a string (usually either "podman" or "docker") representing container runtime - "devcontainer-cli" is also partially supported
        -- -- That is the command that will be invoked for container operations
        -- -- If it is nil, plugin will use whatever is available (trying "podman" first)
        -- container_runtime = nil,
        -- -- Similar to container runtime, but will be used if main runtime does not support an action - useful for "devcontainer-cli"
        -- backup_runtime = nil,
        -- -- This takes a string (usually either "podman-compose" or "docker-compose") representing compose command - "devcontainer-cli" is also partially supported
        -- -- That is the command that will be invoked for compose operations
        -- -- If it is nil, plugin will use whatever is available (trying "podman-compose" first)
        -- compose_command = nil,
        -- -- Similar to compose command, but will be used if main command does not support an action - useful for "devcontainer-cli"
        -- backup_compose_command = nil,
      }
    end
  },
}

--- FILE: /home/jrh/.config/nvim/lua/plugins/telescope.lua ---
return {
    'nvim-telescope/telescope.nvim', tag = '0.1.8',
    -- or                          , branch = '0.1.x',
    dependencies = {
        'nvim-lua/plenary.nvim',
        'nvim-telescope/telescope-ui-select.nvim'
    },
    config = function()
        local telescope = require"telescope"
        telescope.setup {
            -- extensions = {
                -- ['ui-select'] = {
                    -- require('telescope.themes').get_dropdown { }
	}

	telescope.load_extension("ui-select")
    end
}

--- FILE: /home/jrh/.config/nvim/lua/plugins/oil.lua ---
return {
  {
    'stevearc/oil.nvim',
    ---@module 'oil'
    ---@type oil.SetupOpts
    opts = {
      lsp_file_methods = {
        enabled = true,
      },
      show_hidden = false,
      is_hidden_file = function(name, bufnr)
        -- Debug: uncomment this line temporarily to see what names are being passed
        -- print("Oil is_hidden_file called with:", vim.inspect(name))

        -- Hide node_modules directories
        if name == "node_modules" then
          return true
        end

        -- You can also try matching the end of paths in case full paths are passed
        if name:match("/node_modules$") or name:match("\\node_modules$") then
          return true
        end

        -- Don't hide dotfiles - you need to see them as an engineer
        return false
      end,
      -- Alternative: try using the view_options instead
      view_options = {
        is_hidden_file = function(name, bufnr)
          -- Debug: uncomment this line temporarily to see what names are being passed
          -- print("Oil view_options is_hidden_file called with:", vim.inspect(name))

          if name == "node_modules" then
            return true
          end

          -- Try both forward and backslash patterns
          if name:match("/node_modules$") or name:match("\\node_modules$") then
            return true
          end

          return false
        end,
      },
      default_file_explorer = true,
    },
    dependencies = { "nvim-tree/nvim-web-devicons" },
    lazy = false,
    config = function(_, opts)
      require("oil").setup(opts)
    end,
    priority = 100,
  }
}

--- FILE: /home/jrh/.config/nvim/lua/plugins/miscui.lua ---
local keymaps = require("config.keymaps")

return {
  {
    "nvim-tree/nvim-web-devicons",
    config = function()
      local devicons = require"nvim-web-devicons"

      devicons.setup {
        override = {
          norg = {
            icon = "", -- Default icon for Header 1
            color = "#4878BE",
            name = "Norg",
          },
        },
        default = true,
      }

      local default_icons = devicons.get_icons()

      devicons.set_icon {
        pyi = default_icons.pyd,
        latex = default_icons.tex,
        [".latexmkrc"] = default_icons.tex,
        sty = default_icons.tex,
        [".pylintrc"] = default_icons.toml,
        [".python-version"] = default_icons.toml,
        ["Makefile"] = default_icons.makefile,
      }
    end,
  },
  {
    "roobert/tailwindcss-colorizer-cmp.nvim",
    -- optionally, override the default options:
    config = function()
      require("tailwindcss-colorizer-cmp").setup({
        color_square_width = 2,
      })
    end
  },
  -- this is just for markdown/norg/org, move to that when it's set
  -- {
    --   "lukas-reineke/headlines.nvim",
    --   dependencies = "nvim-treesitter/nvim-treesitter",
    --   config = true
    -- },
    -- {
      --   "ramilito/winbar.nvim",
      --   event = "VimEnter", -- Alternatively, BufReadPre if we don't care about the empty file when starting with 'nvim'
      --   dependencies = { "nvim-tree/nvim-web-devicons" },
      --   config = function()
        --     require("winbar").setup({
          --       -- your configuration comes here, for example:
          --       icons = true,
          --       diagnostics = true,
          --       buf_modified = true,
          --       buf_modified_symbol = "M",
          --       -- or use an icon
          --       -- buf_modified_symbol = "●"
          --       background_color = "WinBarNC",
          --       -- or use a hex code:
          --       -- background_color = "#141415",
          --       -- or a different highlight:
          --       -- background_color = "Statusline"
          --       dim_inactive = {
            --         enabled = false,
            --         highlight = "WinBarNC",
            --         icons = true, -- whether to dim the icons
            --         name = true, -- whether to dim the name
            --       }
            --     })
            --   end
  -- },

  {
    "b0o/incline.nvim",
    dependencies = { "lewis6991/gitsigns.nvim" },
    config = function()
      local devicons = require 'nvim-web-devicons'
      require('incline').setup {
        render = function(props)
          local filename = vim.fn.fnamemodify(vim.api.nvim_buf_get_name(props.buf), ':t')
          if filename == '' then
            filename = '[No Name]'
          end
          local ft_icon, ft_color = devicons.get_icon_color(filename)

          local function get_git_diff()
            local icons = { removed = '', changed = '', added = '' }
            local signs = vim.b[props.buf].gitsigns_status_dict
            local labels = {}
            if signs == nil then
              return labels
            end
            for name, icon in pairs(icons) do
              if tonumber(signs[name]) and signs[name] > 0 then
                table.insert(labels, { icon .. signs[name] .. ' ', group = 'Diff' .. name })
              end
            end
            if #labels > 0 then
              table.insert(labels, { '┊ ' })
            end
            return labels
          end

          local function get_diagnostic_label()
            local icons = { error = '', warn = '', info = '', hint = '' }
            local label = {}

            for severity, icon in pairs(icons) do
              local n = #vim.diagnostic.get(props.buf, { severity = vim.diagnostic.severity[string.upper(severity)] })
              if n > 0 then
                table.insert(label, { icon .. n .. ' ', group = 'DiagnosticSign' .. severity })
              end
            end
            if #label > 0 then
              table.insert(label, { '┊ ' })
            end
            return label
          end

          return {
            { get_diagnostic_label() },
            { get_git_diff() },
            { (ft_icon or '') .. ' ', guifg = ft_color, guibg = 'none' },
            { filename .. ' ', gui = vim.bo[props.buf].modified and 'bold,italic' or 'bold' },
            { '┊  ' .. vim.api.nvim_win_get_number(props.win), group = 'DevIconWindows' },
          }
        end,
      }
    end
  },
  {
    "folke/snacks.nvim",
    ---@type snacks.Config
    opts = {
      -- your configuration comes here
      -- or leave it empty to use the default settings
      -- refer to the configuration section below
      dim = {
        ---@type snacks.scope.Config
        scope = {
          min_size = 5,
          max_size = 20,
          siblings = true,
        },
        -- animate scopes. Enabled by default for Neovim >= 0.10
        -- Works on older versions but has to trigger redraws during animation.
        ---@type snacks.animate.Config|{enabled?: boolean}
        animate = {
          enabled = vim.fn.has("nvim-0.10") == 1,
          easing = "outQuad",
          duration = {
            step = 20, -- ms per step
            total = 300, -- maximum duration
          },
        },
        -- what buffers to dim
        filter = function(buf)
          return vim.g.snacks_dim ~= false and vim.b[buf].snacks_dim ~= false and vim.bo[buf].buftype == ""
        end,
      },
      bufdelete = { enabled = true },
      bigfile = { enabled = true },
      input = { enabled = true },
      indent = {
        animate = {
          duration = { step = 5, total = 50 },
        },
      },
      notifier = { enabled = true },
      quickfile = { enabled = true },
      scroll = {
        animate = {
          duration = { step = 5, total = 50 },
          easing = "inOutQuad",
        },
        -- faster animation when repeating scroll after delay
        animate_repeat = {
          delay = 100, -- delay in ms before using the repeat animation
          duration = { step = 5, total = 50 },
          easing = "linear",
        },
        -- what buffers to animate
        filter = function(buf)
          return vim.g.snacks_scroll ~= false and vim.b[buf].snacks_scroll ~= false and vim.bo[buf].buftype ~= "terminal"
        end,
      },
      statuscolumn = { enabled = true },
      git = { enabled = true },
      gitbrowse = { enabled = true },
      lazygit = { enabled = true },
      toggle = {
        {
          map = vim.keymap.set, -- keymap.set function to use
          which_key = true, -- integrate with which-key to show enabled/disabled icons and colors
          notify = true, -- show a notification when toggling
          -- icons for enabled/disabled states
          icon = {
            enabled = " ",
            disabled = " ",
          },
          -- colors for enabled/disabled states
          -- color = {
            --   enabled = "green",
            --   disabled = "yellow",
            -- },
            -- wk_desc = {
              --   enabled = "Disable ",
              --   disabled = "Enable ",
              -- },
            }
          },
          dashboard = { enabled = false },
          explorer = { enabled = false },
          picker = { enabled = false },
          scope = { enabled = false },
          words = { enabled = false },
        }
      },
      {
        "folke/which-key.nvim",
        event = "VeryLazy",
        opts = {
          -- configuration goes here
        },
        -- Just adding them in keymaps.lua
        keys = {},
        config = function()
          keymaps.setup()
        end
      }
    }

--- FILE: /home/jrh/.config/nvim/lua/plugins/lsp.lua ---
local autocmds = require("config.autocmds")
local lspsetup = require("config.lspsetup")

return {
    "neovim/nvim-lspconfig",
    "williamboman/mason.nvim",
    {
      "williamboman/mason-lspconfig.nvim",
      -- Stop race conditions when opening directly to an oil folder view
      dependencies = { "stevearc/oil.nvim" },
      config = function()
        autocmds.setup()
        lspsetup.setup()
      end
    },
    "hrsh7th/nvim-cmp",
    "hrsh7th/cmp-nvim-lsp",
    "hrsh7th/cmp-buffer",
    "saadparwaiz1/cmp_luasnip",
    "L3MON4D3/LuaSnip",
    {
      "nvim-treesitter/nvim-treesitter",
      build = ":TSUpdate",
      config = function()
        require'nvim-treesitter.configs'.setup {
          -- A list of parser names, or "all" (the listed parsers MUST always be installed)
          ensure_installed = "all",

          -- Install parsers synchronously (only applied to `ensure_installed`)
          sync_install = false,

          -- Automatically install missing parsers when entering buffer
          -- Recommendation: set to false if you don't have `tree-sitter` CLI installed locally
          auto_install = true,

          -- List of parsers to ignore installing (or "all")
          -- ignore_install = { "norg" },
          ignore_install = {},

          ---- If you need to change the installation directory of the parsers (see -> Advanced Setup)
          -- parser_install_dir = "/some/path/to/store/parsers", -- Remember to run vim.opt.runtimepath:append("/some/path/to/store/parsers")!

          modules = {},

          highlight = {
            enable = true,

            -- NOTE: these are the names of the parsers and not the filetype. (for example if you want to
            -- disable highlighting for the `tex` filetype, you need to include `latex` in this list as this is
            -- the name of the parser)
            -- list of language that will be disabled
            -- disable = { "c", "rust" },
            -- Or use a function for more flexibility, e.g. to disable slow treesitter highlight for large files
            disable = function(lang, buf)
              local max_filesize = 1000 * 1024 -- 1MB
              local ok, stats = pcall(vim.loop.fs_stat, vim.api.nvim_buf_get_name(buf))
              if ok and stats and stats.size > max_filesize then
                return true
              end
            end,

            -- Setting this to true will run `:h syntax` and tree-sitter at the same time.
            -- Set this to `true` if you depend on 'syntax' being enabled (like for indentation).
            -- Using this option may slow down your editor, and you may see some duplicate highlights.
            -- Instead of true it can also be a list of languages
            additional_vim_regex_highlighting = false,
          },
        }

        -- Tell TS to parse mdx using the markdown parser. See options.setup &
        -- markdown query injections file
        vim.treesitter.language.register('markdown', 'mdx')
      end
    }
}

--- FILE: /home/jrh/.config/nvim/lua/plugins/luadev.lua ---
return {
  {
    "folke/lazydev.nvim",
    ft = "lua", -- only load on lua files
    opts = {
      library = {
        -- See the configuration section for more details
        -- Load luvit types when the `vim.uv` word is found
        { path = "${3rd}/luv/library", words = { "vim%.uv" } },
      },
    },
  },
}

--- FILE: /home/jrh/.config/nvim/lua/plugins/colorscheme.lua ---
return {
  {
    'folke/tokyonight.nvim',
    lazy = false,
    priority = 1000,
    opts = {},
    config = function()
      require('tokyonight').setup {
        -- use the night style
        style = 'night',
        transparent = true,
        -- Style to be applied to different syntax groups
        styles = {
          -- Value is any valid attr-list value for `:help nvim_set_hl`
          comments = { italic = true },
          keywords = { italic = true },
        },
        sidebars = { 'qf', 'vista_kind', 'terminal', 'packer' },
        -- Change the 'hint' color to the 'orange' color, and make the 'error' color bright red
        -- on_colors = function(colors)
        --   colors.hint = colors.orange
        --   colors.error = '#ff0000'
        -- end
        on_highlights = function(hl, c)
          -- hl['@some.treesitter.hlgroup'] = { undercurl = true, strikethrough = true, sp = '#ffffff', fg = c.fg_dark, bg = c.bg_dark }
          hl['netrwTreeBar'] = { fg = c.dark3 }
        end,
      }
      vim.cmd('colorscheme tokyonight-night')
    end
  },
}

--- FILE: /home/jrh/.config/nvim/lua/jrh/init.lua ---
-- Load URI patch first, before anything else
-- require("jrh.uri_patch")

local options = require("config.opts")
local statusline = require("config.statusline")
local tabline = require("config.tabline")

require("config.lazy")

options.setup()
statusline.setup()
tabline.setup()


--- FILE: /home/jrh/.config/nvim/lua/jrh/uri_patch.lua ---
-- TODO: this feels like it shouldn't exist
-- IMPORTANT: This file must be loaded before any plugins
local original_uri_to_fname = vim.uri_to_fname
vim.uri_to_fname = function(uri)
  if uri == nil then
    return nil
  end
  if type(uri) == "string" and uri:match("^oil://") then
    return uri  -- Return the URI directly for oil:// URIs
  end
  return original_uri_to_fname(uri)
end

return true

--- FILE: /home/jrh/.config/nvim/lua/config/autocmds.lua ---
local options = require "config.opts"
local M = {}

local groupopts = { clear = true }
local augroup = vim.api.nvim_create_augroup -- Create/get autocommand group
local autocmd = vim.api.nvim_create_autocmd -- Create autocommand

M.setup = function()
  --[[ Lua Autocmd Example
  -- vim.api.nvim_create_autocmd({"BufEnter", "BufWinEnter"}, {
  --   pattern = {"*.c", "*.h"},
  --   callback = function(ev)
  --     print(string.format('event fired: %s', vim.inspect(ev)))
  --   end
  -- })
  --]]

  -- ============================================================
  -- LSP - TODO: figure out how to not spread oil all over everything
  -- ============================================================
  vim.api.nvim_create_autocmd("BufReadPre", {
    pattern = "oil://*",
    callback = function(args)
      -- Prevent LSP from ever attaching to Oil buffers
      vim.b[args.buf].lsp_disable = true
    end,
  })

  -- ============================================================
  -- Help
  -- ============================================================
  augroup("OpenHelpInTab", groupopts)
  -- NOTE This applies to any *.txt file, which I don't use
  -- (intentionally) myself so it will open any help txt in a new
  -- tab. If any help is triggered again it can cause notice
  -- messages since help is confined to 1 window and the buffers
  -- aren't treated as separate "real' buffers
  autocmd("BufEnter", {
    group = "OpenHelpInTab",
    pattern = "*.txt",
    command = "wincmd T"
  })

  -- ============================================================
  -- General helpers / Common behaviors
  -- ============================================================
  -- Highlight on yank
  augroup('YankHighlight', { clear = true })
  autocmd('TextYankPost', {
    group = 'YankHighlight',
    callback = function()
      vim.highlight.on_yank({ higroup = 'IncSearch', timeout = 1000 })
    end
  })

  -- Remove whitespace on save
  autocmd('BufWritePre', {
    pattern = '*',
    command = ":%s/\\s\\+$//e"
  })

  -- Don't auto commenting new lines
  autocmd('BufEnter', {
    pattern = '*',
    command = 'set fo-=c fo-=r fo-=o'
  })


  -- ============================================================
  -- Filetype-specific settings
  -- ============================================================
  augroup("DisableColorColumn", groupopts)
  autocmd("Filetype", {
    group = "DisableColorColumn",
    pattern = { "help", "markdown", "json" },
    callback = options.disable_colorcolumn,
  })
end

return M

--- FILE: /home/jrh/.config/nvim/lua/config/utils.lua ---
local M = {}

-- @tparam mode string which vim mode
-- @tparam lhs string a key combination
-- @tparam rhs string command to run
-- @tparam opts table vim keymap options
M.keymap = function(mode, lhs, rhs, opts)
  local options = { noremap = true, silent = true }
  if opts then
    options = vim.tbl_extend('force', options, opts)
  end

  -- `nvim_set_keymap` doesn't accept a "buffer" option
  -- this is used for LSP
  if options.buffer then
    vim.keymap.set(mode, lhs, rhs, options)
  else
    vim.api.nvim_set_keymap(mode, lhs, rhs, options)
  end
end

M.open_plugin_url = function()
  local line = vim.api.nvim_get_current_line()
  local plugin = line:match([["([^"]+/[^"]+)"]])
  if not plugin then
    vim.notify("No plugin string found under cursor", vim.log.levels.ERROR)
    return
  end
  local url = "https://github.com/" .. plugin
  local open_cmd
  if vim.fn.has("macunix") == 1 then
    open_cmd = { "open", url }
  elseif vim.fn.has("unix") == 1 then
    open_cmd = { "xdg-open", url }
  else
    vim.notify("Unsupported OS for opening URLs", vim.log.levels.ERROR)
    return
  end
  vim.fn.jobstart(open_cmd, { detach = true })
end

-- M.lsp_on_attach = function(client, bufnr)
--   local keymaps = require"core.keymaps"
--
--   -- Enable completion triggered by <c-x><c-o>
--   vim.api.nvim_set_option_value('omnifunc', 'v:lua.vim.lsp.omnifunc', { buf = bufnr })
--
--   -- Highlighting references.
--   -- See: https://sbulav.github.io/til/til-neovim-highlight-references/
--   -- for the highlight trigger time see: `vim.opt.updatetime`
--   if client.server_capabilities.documentHighlightProvider then
--       vim.api.nvim_create_augroup("lsp_document_highlight", { clear = true })
--       vim.api.nvim_clear_autocmds { buffer = bufnr, group = "lsp_document_highlight" }
--       vim.api.nvim_create_autocmd("CursorHold", {
--           callback = vim.lsp.buf.document_highlight,
--           buffer = bufnr,
--           group = "lsp_document_highlight",
--           desc = "Document Highlight",
--       })
--       vim.api.nvim_create_autocmd("CursorMoved", {
--           callback = vim.lsp.buf.clear_references,
--           buffer = bufnr,
--           group = "lsp_document_highlight",
--           desc = "Clear All the References",
--       })
--   end
--
--   -- Mappings.
--   -- See `:help vim.lsp.*` for documentation on any of the below functions
--   local bufopts = { noremap=true, silent=true, buffer=bufnr }
--
--   -- Setup keymaps
--   for key, val in ipairs(keymaps.lsp) do
--     M.keymap("n", key, val, bufopts)
--   end
-- end

return M;

--- FILE: /home/jrh/.config/nvim/lua/config/keymaps.lua ---
-- TODO: remove whichkey, maybe export LSP keymaps from here somehow?
local constants = require"config.constants"
local utils = require"config.utils"

--[[
  The normal/visual configurations are setup for which-key. Use utils.keymap if
  which-key isn"t in the config.
--]]
local M = {}

local function genfoldkeys_whichkey()
  local folds = {}
  for i = 0, 9 do
    table.insert(folds, {
      "f" .. i,
      ":set foldlevel=" .. i .. "<CR>",
      desc = "Set fold lvl " .. i,
    })
  end
  return folds
end

-- normal mode
local window_traversal_keys_whichkey = {
  { "<C-h>", "<C-w>h", desc = "Move left" },
  { "<C-j>", "<C-w>j", desc = "Move right" },
  { "<C-k>", "<C-w>k", desc = "Move up" },
  { "<C-l>", "<C-w>l", desc = "Move down" },
}

M.setup = function()
  local wk = require"which-key"
  local which_keymaps = {
    -- Arrow keys disabled
    mode = { "n" },
    { "<up>", "<nop>" },
    { "<down>", "<nop>" },
    { "<left>", "<nop>" },
    { "<right>", "<nop>" },

    -- Window resizing
    { "<up>", ":resize -2<CR>", desc = "+/- Win v-size" },
    { "<down>", ":resize +2<CR>", desc = "+/- Win v-size" },
    { "<left>", ":vertical resize -2<CR>", desc = "+/- Win h-size" },
    { "<right>", ":vertical resize +2<CR>", desc = "+/- Win h-size" },

    -- Buffer switching
    { "L", ":bnext<CR>", desc = "Next buffer" },
    { "H", ":bprevious<CR>", desc = "Previous buffer" },

    -- Tab switching
    { constants.IS_MAC and "Ò" or "<A-L>", ":tabn<CR>", desc = "Next tab" },
    { constants.IS_MAC and "Ó" or "<A-H>", ":tabp<CR>", desc = "Previous tab" },

    { constants.IS_MAC and "∆" or "<A-j>", "<Esc>:m .+1<CR>==gi", desc = "Move line up" },
    { constants.IS_MAC and "˚" or "<A-k>", "<Esc>:m .-2<CR>==gi", desc = "Move line down" },

    -- Telescope
    { "<leader>f", group = "Telescope" },
    { "<leader>ff", ":Telescope find_files<CR>", desc = "Find files" },
    { "<leader>fg", ":Telescope live_grep<CR>", desc = "Grep files" },
    { "<leader>fr", ":Telescope oldfiles<CR>", desc = "Old files" },
    { "<leader>fp", ":Telescope projects<CR>", desc = "Projects" },
    { "<leader>fb", ":Telescope buffers<CR>", desc = "Buffers" },

    -- Netrw
    -- { "<leader>et", ":20Vex<CR>", desc = "Netrw side panel" },
    -- { "<leader>ev", ":Vex<CR>", desc = "Netrw (vsplit)" },
    -- { "<leader>es", ":Sex<CR>", desc = "Netrw (split)" },
    -- { "<leader>ew", ":Ex<CR>", desc = "Netrw here (also \"-\")" },
    -- { "-", ":Ex<CR>", desc = "Jump up to Netrw" },

    -- Oil.nvim
    { "<leader>et", "<CMD>Oil --float<CR>", desc = "Oil side panel (float)" },
    { "<leader>ev", "<CMD>vertical Oil<CR>", desc = "Oil (vsplit)" },
    { "<leader>es", "<CMD>split | Oil<CR>", desc = "Oil (split)" },
    { "<leader>ew", "<CMD>Oil<CR>", desc = "Oil here" },
    { "-", "<CMD>Oil<CR>", desc = "Jump up to folder w/ Oil" },

    -- Misc
    { "<leader>u", group = "Utilities" },
    { "<leader>uh", ":nohl<CR>", desc = "UTIL: Clear highlights" },
    { "<leader>up", utils.open_plugin_url, desc = "UTIL: Open Github Plugin URL" },

    -- Splits
    { "<leader>tk", "<C-w>t<C-w>K", desc = "Split Orientation V to H" },
    { "<leader>th", "<C-w>t<C-w>H", desc = "Split Orientation H to V" },

    -- Diffing
    { "<leader>wv", ":set scb<CR>", desc = "Mark buf for sync view" },
    { "<leader>wd", ":diffthis<CR>", desc = "Mark buf for diff" },
  }

  -- Add window traversal keys
  for _, v in ipairs(window_traversal_keys_whichkey) do
    table.insert(which_keymaps, v)
  end

  -- VISUAL mode mappings
  local which_keymaps_v = {
    mode = { "v" },
    { "zL", "zL", desc = "Scroll right" },
    { "zH", "zH", desc = "Scroll left" },
    { "p", "\"_dP", desc = "Better paste" },
    { "<", "<gv", desc = "Better decrease indent" },
    { ">", ">gv", desc = "Better increase indent" },
    { ";", ":", desc = "Command in visual mode" },
  }

  for _, v in ipairs(genfoldkeys_whichkey()) do
    table.insert(which_keymaps_v, v)
  end

  wk.add(which_keymaps)
  wk.add(which_keymaps_v)
end

M.setup_lsp = function(buf)
  local wk = require"which-key"

  wk.add({
    {
      mode = "n",
      buffer = buf,
      { "K", vim.lsp.buf.hover, desc = "LSP: Hover" },
      { "gD", vim.lsp.buf.declaration, desc = "Go to Declaration" },
      { "gd", vim.lsp.buf.definition, desc = "Go to Definition" },
      { "gi", vim.lsp.buf.implementation, desc = "Go to Implementation" },
      { "gr", vim.lsp.buf.references, desc = "Go to References" },
      { "<leadeR>l", group ="lsp" },
      { "<leader>lt", vim.lsp.buf.type_definition, desc = "LSP: Go to Type Definition" },
      { '<leader>ll', vim.diagnostic.setloclist, desc = "LSP: Set loclist" },
      { "<leader>ls", vim.lsp.buf.workspace_symbol, desc = "LSP: View Workspace Symbols" },
      { "<leader>ld", vim.diagnostic.open_float, desc = "LSP: View Diagnostic" },
      { "<leader>la", vim.lsp.buf.code_action, desc = "LSP: View Code Action" },
      { "<leader>lr", vim.lsp.buf.references, desc = "LSP: View References" },
      { "<leader>ln", vim.lsp.buf.rename, desc = "LSP: Rename" },
      {
        "<leader>lwa",
        vim.lsp.buf.add_workspace_folder,
        desc = "LSP: Add Workspace Folder",
      },
      {
        "<leader>lwr",
        vim.lsp.buf.remove_workspace_folder,
        desc = "LSP: Remove Workspace Folder",
      },
      {
        "<leader>lwl",
        function()
          print(vim.inspect(vim.lsp.buf.list_workspace_folders()))
        end,
        desc = "LSP: List Workspace Folders",
      },

      {
        "<leader>lf",
        function()
          vim.lsp.buf.format { async = true }
        end,
        desc = "LSP: Format",
      },
      {
        "[d",
        function()
          vim.diagnostic.jump({ count=1, float=true })
        end,
        desc = "LSP: Next Diagnostic"
      },
      {
        "]d",
        function()
          vim.diagnostic.jump({ count=-1, float=true })
        end,
        desc = "LSP: Previous Diagnostic"
      },
    },
    {
      mode = "i",
      buffer = buf,
      {
        "<C-h>",
        function()
          vim.lsp.buf.signature_help()
        end,
        desc = "LSP: Signature Help"
      },
    },
  })
end


M.get_netrw = function()
  local traversal_keys = {}
  for _, v in pairs(window_traversal_keys_whichkey) do
    traversal_keys[v[1]] = v[2] .. "<CR>"
  end

  return vim.tbl_extend("force", {
    -- Function mappings receive an object describing the node under the cursor
    ["p"]         = function(payload) print(vim.inspect(payload)) end,
    ["<leader>r"] = ":e .<CR>"
    -- String mappings are executed as vim commands
    -- ['<Leader>p'] = ":echo 'hello world'<CR>",
  }, traversal_keys)
end

-- until this is fixed
return M
-- M.netrw = {
--   --[[ Function mappings
--   ["p"] = function(payload)
--     -- Payload is an object describing the node under the cursor, the object
--     -- has the following keys:
--     -- - dir: the current netrw directory (vim.b.netrw_curdir)
--     -- - node: the name of the file or directory under the cursor
--     -- - link: the referenced file if the node under the cursor is a symlink
--     -- - extension: the file extension if the node under the cursor is a file
--     -- - type: the type of node under the cursor (0=dir, 1=file, 2=symlink)
--     -- - col: the column of the node (for liststyle 3)
--     print(vim.inspect(payload))
--   end,
--   -- String command mappings
--   ["<Leader><Tab>"] = ":echo "string command"<CR>",
--   --]]
-- }
-- M.cmp = {
--   -- Since we're requiring modules, I want to make sure this is
--   -- loaded when the module is configured so it's invoked in the
--   -- cmp config.
--   get_mapping_presets = function()
--     local cmp = require"cmp"
--     local luasnip = require"luasnip"
--
--     local check_backspace = function()
--       local col = vim.fn.col(".") - 1
--       return col == 0 or vim.fn.getline("."):sub(col, col):match("%s")
--     end
--
--     return {
--       ["<C-k>"] = cmp.mapping.select_prev_item(),
--       ["<C-j>"] = cmp.mapping.select_next_item(),
--       ["<C-b>"] = cmp.mapping(cmp.mapping.scroll_docs(-1), { "i", "c" }),
--       ["<C-f>"] = cmp.mapping(cmp.mapping.scroll_docs(1), { "i", "c" }),
--       ["<C-Space>"] = cmp.mapping(cmp.mapping.complete(), { "i", "c" }),
--       ["<C-e>"] = cmp.mapping({
--         i = cmp.mapping.abort(),
--         c = cmp.mapping.close(),
--       }),
--       -- Accept currently selected item. If none selected, `select` first item.
--       -- Set `select` to `false` to only confirm explicitly selected items.
--       ["<CR>"] = cmp.mapping.confirm({ select = true }),
--       ["<Tab>"] = cmp.mapping(function(fallback)
--           if cmp.visible() then
--             cmp.select_next_item()
--           elseif luasnip.expandable() then
--             luasnip.expand()
--           elseif luasnip.expand_or_jumpable() then
--             luasnip.expand_or_jump()
--           elseif check_backspace() then
--             fallback()
--           else
--             fallback()
--           end
--         end, {
--         "i",
--         "s",
--       }),
--       ["<S-Tab>"] = cmp.mapping(function(fallback)
--         if cmp.visible() then
--           cmp.select_prev_item()
--         elseif luasnip.jumpable(-1) then
--           luasnip.jump(-1)
--         else
--           fallback()
--         end
--       end, {
--         "i",
--         "s",
--       }),
--     }
--   end,
--   which_key = {
--     {
--       name = "CMP Key Helper (not normal)",
--     }
--   },
-- }
--
-- return M

--- FILE: /home/jrh/.config/nvim/lua/config/constants.lua ---
local M = {}

---@diagnostic disable-next-line: undefined-field
M.IS_MAC = vim.loop.os_uname().sysname == "Darwin"

M.WINDOW_STYLE = {
  focusable = false,
  style = "minimal",
  border = "rounded",
  source = "always",
  header = "",
  prefix = "",
}

M.CMP_KIND_ICONS = {
	Text = "󰊄",
	Method = "",
	Function = "󰊕",
	Constructor = "",
  Field = "",
  Variable = "󱄑", -- "",
	Class = "", -- "",
	Interface = "",
	Module = "󰕳",
	Property = "",
	Unit = "",
	Value = "󰫧",
	Enum = "",
	Keyword = "",
	Snippet = "",
	Color = "󰉦",
	File = "",
	Reference = "",
	Folder = "",
	EnumMember = "",
	Constant = "󰀱",
	Struct = "",
	Event = "",
	Operator = "",
	TypeParameter = "",
}

return M

--- FILE: /home/jrh/.config/nvim/lua/config/lspsetup.lua ---
local keymaps = require("config.keymaps")

local M = {}

M.setup = function()
  vim.api.nvim_create_autocmd('LspAttach', {
    group = vim.api.nvim_create_augroup('user_lsp_attach', {clear = true}),
    callback = function(event)
      -- Detach LSP if buffer is not a normal file
      local buftype = vim.api.nvim_get_option_value("buftype", { buf = event.buf })
      local bufname = vim.api.nvim_buf_get_name(event.buf)
      if buftype ~= "" or bufname == "" or bufname:match("^oil://") then
        vim.schedule(function()
          local clients = vim.lsp.get_active_clients({ bufnr = event.buf })
          for _, client in ipairs(clients) do
            vim.lsp.buf_detach_client(event.buf, client.id)
          end
        end)
        return
      end

      keymaps.setup_lsp(event.buf)
    end,
  })

  local function is_real_file(bufnr)
    local buftype = vim.api.nvim_get_option_value("buftype", { buf = bufnr })
    local bufname = vim.api.nvim_buf_get_name(bufnr)
    return buftype == "" and bufname ~= "" and not bufname:match("^oil://")
  end

  local lsp_capabilities = require('cmp_nvim_lsp').default_capabilities()

  require('mason').setup({})
  require('mason-lspconfig').setup({
    automatic_enable = true, -- { exclude = {} }
    ensure_installed = {
      'vtsls', 'bashls', 'clangd', 'cmake', 'css_variables',
      'cssls', 'cssmodules_ls', 'tailwindcss', 'docker_compose_language_service',
      'dockerls', 'jinja_lsp', 'ast_grep', 'html', 'biome', -- 'denols',
      'eslint', 'yamlls', 'lwc_ls', 'jsonls', 'lua_ls',
      'marksman', 'perlnavigator', 'pyright', 'ruff', 'sqls', 'vimls',
      'custom_elements_ls',

      -- test which to use
      -- 'harper_ls',
      'typos_lsp',

      -- 'awk_ls', -- Always fails to install and throws errors
      -- 'ts_ls',
      -- textlsp | Grammar/spellcheck w/ AI integrations, needs config
    },
    handlers = {
      function(server_name)
        require('lspconfig')[server_name].setup({
          capabilities = lsp_capabilities,
          root_dir = function(fname)
            -- Handle nil or empty fname
            if not fname or fname == "" then
              return nil
            end

            -- Don't try to find a root dir for oil:// URIs
            if fname:match("^oil://") then
              return nil
            end

            -- Use a safer root pattern that handles edge cases
            local util = require('lspconfig.util')
            local root = util.root_pattern('.git', 'package.json', 'tsconfig.json', 'pyproject.toml', 'Cargo.toml')(fname)

            if not root then
              -- Fallback to the directory containing the file
              return vim.fn.fnamemodify(fname, ':h')
            end

            return root
          end,
          autostart = function(bufnr)
            if vim.b[bufnr].lsp_disable then
              return false
            end
            local bufname = vim.api.nvim_buf_get_name(bufnr)
            if bufname:match("^oil://") then
              return false
            end
            return true
          end,
          on_init = function(client)
            local bufnr = vim.api.nvim_get_current_buf()
            if not is_real_file(bufnr) or vim.api.nvim_buf_get_name(bufnr):match("^oil://") then
              client.stop()
              return false
            end
          end,
        })
      end,
      lua_ls = function()
        require('lspconfig').lua_ls.setup({
          capabilities = lsp_capabilities,
          settings = {
            Lua = {
              runtime = {
                version = 'LuaJIT'
              },
              diagnostics = {
                globals = {'vim'},
              },
              workspace = {
                library = {
                  vim.env.VIMRUNTIME,
                }
              }
            }
          }
        })
      end,
      vtsls = function()
        require('lspconfig').vtsls.setup({
          capabilities = lsp_capabilities,
          settings = {
            typescript = {
              tsdk = "./node_modules/typescript/lib",
            },
            vtsls = {
              autoUseWorkspaceTsdk = true,
            },
          },
        })
      end,
    }
  })

  local cmp = require('cmp')
  local cmp_select = {behavior = cmp.SelectBehavior.Select}
  local constants = require('config.constants')

  cmp.setup({
    sources = cmp.config.sources({
      {name = 'nvim_lsp'},
      {name = 'luasnip'},
      {name = 'buffer'},
      {name = 'codecompanion'},
    }, {
      {
        name="lazydev",
        group_index = 0,
      }
    }),
    mapping = cmp.mapping.preset.insert({
      ['<C-p>'] = cmp.mapping.select_prev_item(cmp_select),
      ['<C-n>'] = cmp.mapping.select_next_item(cmp_select),
      ['<C-y>'] = cmp.mapping.confirm({select = true}),
      ['<C-Space>'] = cmp.mapping.complete(),
    }),
    formatting = {
      fields = { "kind", "abbr" },
      format = function(_, vim_item)
        vim_item.kind = constants.CMP_KIND_ICONS[vim_item.kind] or ""
        return vim_item
      end,
    },
    snippet = {
      expand = function(args)
        require('luasnip').lsp_expand(args.body)
      end,
    },
  })
end

return M

--- FILE: /home/jrh/.config/nvim/lua/config/tabline.lua ---
-- Found on Github - VonHeikemen/nvim-starter
local M = {}
local concat  = '%s%s'
local active_tab_highlight = 'UserTablineSeparator'
local separator_active = ''

function M.setup()
  M.set_separator()
  _G._user_tabline = M.tabline
  vim.o.tabline = '%!v:lua._user_tabline()'
end

function M.tabpage(opts)
  local highlight = '%#TabLine#'
  local separator = '%#TabLine#▏'
  local label = '[No Name 2309512345]'

  if opts.selected then
    highlight = '%#TabLineSel#'
    separator = separator_active
  end

  if opts.bufname ~= '' then
    label = vim.fn.pathshorten(vim.fn.fnamemodify(opts.bufname, ':p:~:t'))
  end

  return string.format('%s%s%s ', separator, highlight, label)
end

function M.tabline()
  local line = ''
  local tabs = vim.fn.tabpagenr('$')

  for index = 1, tabs, 1 do
    local buflist = vim.fn.tabpagebuflist(index)
    local winnr = vim.fn.tabpagewinnr(index)
    local bufname = vim.fn.bufname(buflist[winnr])

    line = concat:format(
      line,
      M.tabpage({
        selected = vim.fn.tabpagenr() == index,
        bufname = bufname,
      })
    )
  end

  line = concat:format(line, '%#TabLineFill#%=')

  if tabs > 1 then
    line = concat:format(line, '%#TabLine#%999XX')
  end

  return line
end

function M.set_separator()
  local ok, hl = pcall(vim.api.nvim_get_hl_by_name, active_tab_highlight, 1)
  local valid_highlight = ok and (hl.background or hl.foreground)

  if not valid_highlight then
    vim.api.nvim_set_hl(0, active_tab_highlight, {link = 'Directory'})
  end

  separator_active = string.format('%%#%s#▍', active_tab_highlight)
end

function M.higroups()
  return {
    ['TABLINE-SEPARATOR'] = active_tab_highlight
  }
end

return M


--- FILE: /home/jrh/.config/nvim/lua/config/lazy.lua ---
-- Bootstrap lazy.nvim
local lazypath = vim.fn.stdpath("data") .. "/lazy/lazy.nvim"
if not (vim.uv or vim.loop).fs_stat(lazypath) then
  local lazyrepo = "https://github.com/folke/lazy.nvim.git"
  local out = vim.fn.system({ "git", "clone", "--filter=blob:none", "--branch=stable", lazyrepo, lazypath })
  if vim.v.shell_error ~= 0 then
    vim.api.nvim_echo({
      { "Failed to clone lazy.nvim:\n", "ErrorMsg" },
      { out, "WarningMsg" },
      { "\nPress any key to exit..." },
    }, true, {})
    vim.fn.getchar()
    os.exit(1)
  end
end
vim.opt.rtp:prepend(lazypath)

-- Make sure to setup `mapleader` and `maplocalleader` before
-- loading lazy.nvim so that mappings are correct.
-- This is also a good place to setup other settings (vim.opt)
vim.g.mapleader = " "
vim.g.maplocalleader = "\\"

-- Setup lazy.nvim
require("lazy").setup({
  spec = {
    -- import your plugins
    { import = "plugins" },
  },
  -- Configure any other settings here. See the documentation for more details.
  -- colorscheme that will be used when installing plugins.
  install = { colorscheme = { "habamax" } },
  -- automatically check for plugin updates
  checker = { enabled = true },
})

--- FILE: /home/jrh/.config/nvim/lua/config/statusline.lua ---
-- Found on Github - VonHeikemen/nvim-starter
local M = {}
local state = {}

local function default_hl(name, style, opts)
  opts = opts or {}
  local ok, hl = pcall(vim.api.nvim_get_hl_by_name, name, 1)
  if ok and (hl.background or hl.foreground) then
    return
  end

  if opts.link then
    vim.api.nvim_set_hl(0, name, {link = style})
    return
  end

  local normal = vim.api.nvim_get_hl_by_name('Normal', 1)
  local fallback = vim.api.nvim_get_hl_by_name(style, 1)

  vim.api.nvim_set_hl(0, name, {fg = normal.background, bg = fallback.foreground})
end

local mode_higroups = {
  ['NORMAL'] = 'UserStatusMode_NORMAL',
  ['VISUAL'] = 'UserStatusMode_VISUAL',
  ['V-BLOCK'] = 'UserStatusMode_V_BLOCK',
  ['V-LINE'] = 'UserStatusMode_V_LINE',
  ['INSERT'] = 'UserStatusMode_INSERT',
  ['COMMAND'] = 'UserStatusMode_COMMAND',
}

local function apply_hl()
  default_hl('UserStatusBlock', 'StatusLine', {link = true})
  default_hl('UserStatusMode_DEFAULT', 'Comment')

  default_hl(mode_higroups['NORMAL'],  'Directory')
  default_hl(mode_higroups['VISUAL'],  'Number')
  default_hl(mode_higroups['V-BLOCK'], 'Number')
  default_hl(mode_higroups['V-LINE'],  'Number')
  default_hl(mode_higroups['INSERT'],  'String')
  default_hl(mode_higroups['COMMAND'], 'Comment')
end

-- mode_map copied from:
-- https://github.com/nvim-lualine/lualine.nvim/blob/5113cdb32f9d9588a2b56de6d1df6e33b06a554a/lua/lualine/utils/mode.lua
local mode_map = {
  ['n']      = 'NORMAL',
  ['no']     = 'O-PENDING',
  ['nov']    = 'O-PENDING',
  ['noV']    = 'O-PENDING',
  ['no\22']  = 'O-PENDING',
  ['niI']    = 'NORMAL',
  ['niR']    = 'NORMAL',
  ['niV']    = 'NORMAL',
  ['nt']     = 'NORMAL',
  ['v']      = 'VISUAL',
  ['vs']     = 'VISUAL',
  ['V']      = 'V-LINE',
  ['Vs']     = 'V-LINE',
  ['\22']    = 'V-BLOCK',
  ['\22s']   = 'V-BLOCK',
  ['s']      = 'SELECT',
  ['S']      = 'S-LINE',
  ['\19']    = 'S-BLOCK',
  ['i']      = 'INSERT',
  ['ic']     = 'INSERT',
  ['ix']     = 'INSERT',
  ['R']      = 'REPLACE',
  ['Rc']     = 'REPLACE',
  ['Rx']     = 'REPLACE',
  ['Rv']     = 'V-REPLACE',
  ['Rvc']    = 'V-REPLACE',
  ['Rvx']    = 'V-REPLACE',
  ['c']      = 'COMMAND',
  ['cv']     = 'EX',
  ['ce']     = 'EX',
  ['r']      = 'REPLACE',
  ['rm']     = 'MORE',
  ['r?']     = 'CONFIRM',
  ['!']      = 'SHELL',
  ['t']      = 'TERMINAL',
}

local fmt = string.format
local hi_pattern = '%%#%s#%s%%*'

function _G._statusline_component(name)
  return state[name]()
end

local function show_sign(mode)
  local empty = ' '

  -- This just checks a user defined variable
  -- it ignores completely if there are active clients
  if vim.b.lsp_attached == nil then
    return empty
  end

  local ok = ' λ '
  local ignore = {
    ['INSERT'] = true,
    ['COMMAND'] = true,
    ['TERMINAL'] = true
  }

  if ignore[mode] then
    return ok
  end

  local levels = vim.diagnostic.severity
  local errors = #vim.diagnostic.get(0, {severity = levels.ERROR})
  if errors > 0 then
    return ' ✘ '
  end

  local warnings = #vim.diagnostic.get(0, {severity = levels.WARN})
  if warnings > 0 then
    return ' ▲ '
  end

  return ok
end

state.show_diagnostic = false
state.mode_group = mode_higroups['NORMAL']

function state.mode()
  local mode = vim.api.nvim_get_mode().mode
  local mode_name = mode_map[mode]
  local text = ' '

  local higroup = mode_higroups[mode_name]

  if higroup then
    state.mode_group = higroup
    if state.show_diagnostic then
      text = show_sign(mode_name)
    end

    return fmt(hi_pattern, higroup, text)
  end

  state.mode_group = 'UserStatusMode_DEFAULT'
  text = fmt(' %s ', mode_name)
  return fmt(hi_pattern, state.mode_group, text)
end

function state.position()
  return fmt(hi_pattern, state.mode_group, ' %3l:%-2c ')
end

state.percent = fmt(hi_pattern, 'UserStatusBlock', ' %2p%% ')

-- TODO move this to the theme
vim.cmd[[
  hi Container guifg=#BADA55 guibg=Black
]]

state.full_status = {
  '%{%v:lua._statusline_component("mode")%} ',
  (vim.g.currentContainer ~= nil and '%#Container#%{g:currentContainer} ' or ''),
  '%t',
  '%r',
  '%m',
  '%=',
  '%{&filetype} ',
  state.percent,
  '%{%v:lua._statusline_component("position")%}'
}

state.short_status = {
  state.full_status[1],
  '%=',
  state.percent,
  state.full_status[8]
}

state.inactive_status = {
  '%t',
  '%r',
  '%m',
  '%=',
  '%{&filetype} |',
  ' %2p%% | ',
  '%3l:%-2c ',
}

function M.setup()
  local augroup = vim.api.nvim_create_augroup('statusline_cmds', {clear = true})
  local autocmd = vim.api.nvim_create_autocmd
  vim.opt.showmode = false

  apply_hl()
  local pattern = M.get_status('full')
  if pattern then
    vim.o.statusline = pattern
  end

  local lsp_attach_event = 'LspAttach'
  local lsp_attach_pattern

  if vim.lsp.start == nil then
    lsp_attach_event = 'User'
    lsp_attach_pattern = 'LspAttached'
  end

  autocmd(lsp_attach_event, {
    pattern = lsp_attach_pattern,
    group = augroup,
    desc = 'Show diagnostic sign',
    callback = function()
      vim.b.lsp_attached = 1
      state.show_diagnostic = true
    end
  })

  autocmd('ColorScheme', {
    group = augroup,
    desc = 'Apply statusline highlights',
    callback = apply_hl
  })
  autocmd('FileType', {
    group = augroup,
    pattern = {'netrw'},
    desc = 'Apply short statusline',
    callback = function()
      vim.w.status_style = 'short'
      vim.wo.statusline = M.get_status('short')
    end
  })
  autocmd('InsertEnter', {
    group = augroup,
    desc = 'Clear message area',
    command = "echo ''"
  })
  autocmd('WinEnter', {
    group = augroup,
    desc = 'Change statusline',
    callback = function()
      local winconfig = vim.api.nvim_win_get_config(0)
      if winconfig.relative ~= '' then
        return
      end

      local style = vim.w.status_style
      if style == nil then
        style = 'full'
        vim.w.status_style = style
      end

      vim.wo.statusline = M.get_status(style)

      local winnr = vim.fn.winnr('#')
      if winnr == 0 then
        return
      end

      local curwin = vim.api.nvim_get_current_win()
      local winid = vim.fn.win_getid(winnr)
      if winid == 0 or winid == curwin then
        return
      end

      if vim.api.nvim_win_is_valid(winid) then
        vim.wo[winid].statusline = M.get_status('inactive')
      end
    end
  })
end



function M.get_status(name)
  return table.concat(state[fmt('%s_status', name)], '')
end

function M.apply(name)
  vim.o.statusline = M.get_status(name)
end

function M.higroups()
  local res = vim.deepcopy(mode_higroups)
  res['DEFAULT'] = 'UserStatusMode_DEFAULT'
  res['STATUS-BLOCK'] = 'UserStatusBlock'
  return res
end

M.default_hl = apply_hl

return M

--- FILE: /home/jrh/.config/nvim/lua/config/opts.lua ---
local M = {}

local g = vim.g       -- Global variables
local opt = vim.opt   -- Set options (global/buffer/windows-scoped)

-- ============================================================
-- Utilities / Callbacks
-- ============================================================
M.disable_colorcolumn = function()
  -- Disable line-length column
  opt.colorcolumn = ""
end

M.set_full_conceal = function()
  opt.conceallevel = 3
end

-- ============================================================
-- Setup
-- ============================================================
M.setup = function()
  -- ============================================================
  -- General
  -- ============================================================
  opt.mouse = "a"                                -- Enable mouse support
  opt.clipboard = "unnamedplus"                  -- Use system clipboard
  opt.swapfile = false                           -- Don"t use swapfile
  opt.completeopt = "menuone,noinsert,noselect"  -- Autocomplete options

  -- ============================================================
  -- Neovim UI
  -- ============================================================
  opt.winborder = "rounded"   -- Set global winborder for Neovim 0.11+
  opt.number = true           -- Show line numbers
  opt.relativenumber = true   -- Make line relative numbers
  opt.showmatch = true        -- Highlight matching parenthesis
  -- opt.foldmethod = "marker"   -- Enable folding (default "foldmarker")
  opt.colorcolumn = "80"      -- Line length marker at 80 columns
  opt.splitright = true       -- Vertical split to the right
  opt.splitbelow = true       -- Horizontal split to the bottom
  opt.ignorecase = true       -- Ignore case letters when search
  opt.smartcase = true        -- Ignore lowercase for the whole pattern
  opt.linebreak = true        -- Wrap on word boundary
  opt.termguicolors = true    -- Enable 24-bit RGB colors
  opt.laststatus = 3          -- Set global statusline

  -- ============================================================
  -- Netrw
  -- ============================================================
  -- g.netrw_banner = 0                  -- Disable the header banner
  -- g.netrw_sort_sequence = [[[\/]$,*]] -- Sort dirs first
  -- g.netrw_liststyle = 3               -- Tree view by default
  -- g.netrw_sizestyle = "H"             -- Human readable file size
  -- g.netrw_keepdir = 1                 -- Keep view/browse dir synced, avoid move error
  -- Patterns for hiding files, e.g. node_modules
  -- NOTE: this works by reading '.gitignore' file
  -- g.netrw_list_hide = vim.fn["netrw_gitignore#Hide"]()

  -- Preview files in a vertical split window
  -- vim.g.netrw_preview = 1

  -- -- Open files in split
  -- -- 0 : re-use the same window (default)
  -- -- 1 : horizontally splitting the window first
  -- 2 : vertically   splitting the window first
  -- 3 : open file in new tab
  -- 4 : act like "P" (ie. open previous window)
  -- g.netrw_browse_split = 4

  -- FROM DOOM
  -- See more https://github.com/doom-neovim/doom-nvim/blob/d878cd9a69eb86ad10177d3f974410317ab9f2fe/lua/doom/modules/features/netrw/init.lua

  -- Setup file operations commands
  -- TODO: figure out how to add these feature in Windows
  if package.config:sub(1, 1) == "/" then
    -- Enable recursive copy of directories in *nix systems
    vim.g.netrw_localcopydircmd = "cp -r"

    -- Enable recursive creation of directories in *nix systems
    vim.g.netrw_localmkdir = "mkdir -p"

    vim.g.netrw_localmovecmd = "mv"

    -- Enable recursive removal of directories in *nix systems
    -- NOTE: we use 'rm' instead of 'rmdir' (default) to be able to remove non-empty directories
    vim.g.netrw_localrmdir = "rm -r"
  end

  -- ============================================================
  -- Tabs, indent
  -- ============================================================
  opt.expandtab = true        -- Use spaces instead of tabs
  opt.shiftwidth = 2          -- Shift 4 spaces when tab
  opt.tabstop = 2             -- 1 tab == 4 spaces
  opt.smartindent = true      -- Autoindent new lines

  -- ============================================================
  -- Memory, CPU
  -- ============================================================
  opt.hidden = true           -- Enable background buffers
  opt.history = 100           -- Remember N lines in history
  -- This doesn't work with noice
  -- opt.lazyredraw = true       -- Faster scrolling
  opt.synmaxcol = 240         -- Max column for syntax highlight
  opt.updatetime = 250        -- ms to wait for trigger an event

  -- ============================================================
  -- Migrated
  -- ============================================================
  opt.backup = false                           -- creates a backup file
  opt.background = "dark"                      -- set background for colorscheme
  opt.cmdheight = 1                            -- more space in the neovim command line for displaying messages
  opt.completeopt = { "menuone", "noselect" }  -- mostly just for cmp
  opt.conceallevel = 0                         -- so that `` is visible in markdown files
  opt.fileencoding = "utf-8"                   -- the encoding written to a file
  opt.hlsearch = true                          -- highlight all matches on previous search pattern
  opt.pumheight = 10                           -- pop up menu height
  opt.showmode = false                         -- we don"t need to see things like -- INSERT -- anymore
  opt.showtabline = 1                          -- show tabs when there's >1
  opt.timeoutlen = 1000                        -- time to wait for a mapped sequence to complete (in milliseconds)
  opt.undofile = true                          -- enable persistent undo
  opt.writebackup = false                      -- if a file is being edited by another program (or was written to file while editing with another program) it is not allowed to be edited
  opt.cursorline = true                        -- highlight the current line
  opt.showcmd = false                          -- hide (partial) command in the last line of the screen (for performance)
  opt.ruler = false                            -- hide the line and column number of the cursor position
  opt.numberwidth = 4                          -- minimal number of columns to use for the line number {default 4}
  opt.signcolumn = "yes"                       -- always show the sign column, otherwise it would shift the text each time
  opt.scrolloff = 8                            -- minimal number of screen lines to keep above and below the cursor
  opt.sidescrolloff = 8                        -- minimal number of screen columns to keep to the left and right of the cursor if wrap is `false`
  -- opt.guifont = "monospace:h17"                -- the font used in graphical neovim applications
  opt.foldmethod = "expr"
  opt.foldexpr = "nvim_treesitter#foldexpr()"
  opt.foldlevel = 999
  -- TODO: This isn"t the proper place to set this
  -- nofoldenable = true

  -- Sub options
  opt.fillchars.eob=" "                        -- show empty lines at the end of a buffer as ` ` {default `~`}
  opt.shortmess:append "c"                     -- hide all the completion messages, e.g. "-- XXX completion (YYY)", "match 1 of 2", "The only match", "Pattern not found"
  opt.whichwrap:append("<,>,[,],h,l")          -- keys allowed to move to the previous/next line when the beginning/end of line is reached
  opt.iskeyword:append("-")                    -- treats words with `-` as single words
  opt.formatoptions:remove({ "c", "r", "o" })  -- This is a sequence of letters which describes how automatic formatting is to be done


  -- ============================================================
  -- Filetypes
  -- ============================================================
  -- See Treesitter config for mdx registration
  vim.filetype.add({
    extension = {
      mdx = 'mdx',
    }
  })

  -- ============================================================
  -- Startup
  -- ============================================================
  -- Disable nvim intro
  -- opt.shortmess:append "sI"

  -- Disable builtin plugins
  local disabled_built_ins = {
    "2html_plugin",
    "getscript",
    "getscriptPlugin",
    "gzip",
    "logipat",
    "netrw",
    "netrwPlugin",
    "netrwSettings",
    "netrwFileHandlers",
    "matchit",
    "tar",
    "tarPlugin",
    "rrhelper",
    "spellfile_plugin",
    "vimball",
    "vimballPlugin",
    "zip",
    "zipPlugin",
    "tutor",
    "rplugin",
    "synmenu",
    "optwin",
    "compiler",
    "bugreport",
    "ftplugin",
  }

  for _, plugin in pairs(disabled_built_ins) do
     g["loaded_" .. plugin] = 1
  end
end

return M


--- FILE: /home/jrh/.config/nvim/README.md ---
# neoconfig
The latest config: An attempt at a paired-down config with LSP

